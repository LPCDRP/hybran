#!/usr/bin/env python2.7
import os
import argparse
import logging
import time

from lib import \
    verifyInstallations, \
    fileManager, \
    firstReference, \
    run, \
    annomerge, \
    converter

__version__ = '1.0'


def cmds():
    """
    argparse parse input provided by the user

    :return: argparse.parse_args() object
    """
    parser = argparse.ArgumentParser(description='Annotate TUBerculosis: a pipeline to annotate Mycobacterium '
                                                 'tuberculosis de novo assembled genomes. Annotation of other species '
                                                 'or mixing species within an annotation run is NOT recommended.'
                                                 '\n\nPlease cite: [manuscript submitted]')
    required = parser.add_argument_group('Required')
    optional = parser.add_argument_group('Optional')
    required.add_argument('-g', '--genomes', help='Directory containing all genomes desired to be annotated. '
                                                  'FASTA format required',
                          required=True)
    required.add_argument('-r', '--references', help='Directory containing EMBL and Genbank files of reference '
                                                     'annotations to transfer. Only the first 30 reference annotations '
                                                     'will be transferred with RATT and the first annotation will '
                                                     'be used as the reference database in the Prokka reference '
                                                     'step.',
                          required=True)
    required.add_argument('-e', '--eggnog-databases', help='Directory of the eggnog databases downloaded using '
                                                           'download_eggnog_data.py. Full path only',
                          dest='database_dir',
                          required=True)
    optional.add_argument('-o', '--output', help='Directory to output all new annotation files. Default is the '
                                                 '-r/--references directory. Full path only')
    optional.add_argument('-n', '--nproc', help='Number of processors/CPUs to use. Default is 1',
                          default='1')
    optional.add_argument('-v', '--version', help='Print version and exit',
                          action='store_true')
    optional.add_argument('--verbose', action='store_true', help='Verbose output')
    return parser.parse_args()


def main():
    """
    Annotate TUBerculosis: a pipeline to annotate Mycobacterium
    tuberculosis de novo assembled genomes. Annotation of other species
    or mixing species within an annotation run is NOT recommended.

    :return: None
    """
    args = cmds()
    # Obtaining the absolute path to all scripts
    script_dir = os.path.abspath(os.path.dirname(__file__))

    if args.version:
        print __version__
        exit()

    # Confirming all installations are valid
    verifyInstallations.verify_installations(args.database_dir)

    # Setting up logging
    start_time = time.time()
    print '\n\t\t\tPlease cite:\n\t\t\t[manuscript submitted]\n\n'
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG,
                            format='%(asctime)s:%(levelname)s:%(name)s:%(message)s')
    else:
        logging.basicConfig(level=logging.INFO,
                            format='%(asctime)s:%(levelname)s:%(name)s:%(message)s')
    logger = logging.getLogger('AnnoTUB')
    output_provided = True
    if not args.output:
        args.output = args.references
        output_provided = False
    cwd = os.getcwd() + '/'

    # Convert all input paths to full path if not given as full path
    args.genomes = fileManager.full_path(args.genomes)
    args.references = fileManager.full_path(args.references)
    args.output = fileManager.full_path(args.output)

    # Moving into the desired annotation directory
    os.chdir(args.output)

    # Setting up RATT references
    refdir, embl_dir, embls = fileManager.ratt_references(args)

    # Getting first reference information
    first_reference_embl = embls[0]
    first_reference_gbk = args.references + first_reference_embl.split('.')[0] + '.gbk'
    ref_cds, ref_genome = firstReference.get_first_reference_proteome(first_reference_gbk)

    # Calling all steps for AnnoTUB
    genome_count = 0
    for f in os.listdir(args.genomes):
        if f.endswith('.fasta'):
            genome_count += 1
            filename = f.split('.')[0]
            run.ratt_prokka(ref_dir=embl_dir,
                            fasta=args.genomes + f,
                            ref_cds=args.output + ref_cds,
                            script_dir=script_dir,
                            cpus=args.nproc)
            if filename + '.gbk' not in os.listdir(os.getcwd()):
                logger.info('Merging RATT and Prokka annotations for ' + filename)
                annomerge.run(isolate_id=filename,
                              annotation_fp=os.getcwd() + '/',
                              ref_proteins_fasta=ref_cds,
                              ref_embl_fp=embl_dir + first_reference_embl,
                              reference_genome=ref_genome,
                              script_directory=script_dir)
            if filename + '.gff' not in os.listdir(os.getcwd()):
                converter.convert_gbk_to_gff(filename + '.gbk')
    if output_provided:
        annotations_dir = [args.output, refdir]
    else:
        annotations_dir = [args.output]
    run.clustering(annotations=annotations_dir,
                   nproc=args.nproc)
    run.eggnog_mapper(script_dir=script_dir,
                      nproc=args.nproc,
                      emapper_loc=args.database_dir)
    logger.info('Finished. Annotated ' + str(genome_count) + ' genomes. Genbank and GFF are located in ' + args.output)
    logger.info('Time elapsed: ' + str((time.time() - start_time) / 60.0) + 'min')
    logger.info('Thank you for using AnnoTUB. We hope to see you again!')


if __name__ == '__main__':
    main()
